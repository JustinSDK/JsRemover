<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html dir="ltr" lang="en">
  <head>
    <meta http-equiv="content-type" content="text/html; charset=UTF-8">
    <title>Prototype Chains</title>
    <meta content="caterpillar" name="author">
    <meta content="JavaScript Prototype Chain" name="keywords">
    <link href="css/std.css" rel="stylesheet" type="text/css">
  </head>
  <body>
    <div class="header">
      <div class="hgroup">
        <h3><a href="http://openhome.cc/eGossip/">From eGossip@Openhome</a></h3>
        <h1><a href="index.html">JavaScript Essence: Prototype Chains<br>
          </a></h1>
      </div>
    </div>
    <div class="article">
      <div align="right"><a href="../../Gossip/JavaScript/Prototype.html">中文</a><br>
      </div>
      <br>
      We've seen an example in <a href="Constructors.html">Constructors</a>.<br>
      <blockquote><strong><span class="courier">function Person(name, age) {</span><br>
          <span class="courier">&nbsp;&nbsp;&nbsp; this.name = name;</span><br>
          <span class="courier">&nbsp;&nbsp;&nbsp; this.age = age;</span><br>
          <span class="courier">&nbsp;&nbsp;&nbsp; this.toString = function() {</span><br>
          <span class="courier">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return '[' + this.name + ', ' + this.age + ']';</span><br>
          <span class="courier">&nbsp;&nbsp;&nbsp; };</span><br>
          <span class="courier">}</span><br>
        </strong></blockquote>
      In <span class="courier">Person</span>, it uses a function literal to create a function and assigns it to the <span
        class="courier">toString</span> property of <span class="courier">this</span>. Every time you use the constructor function to create an instance, you also create a new function.<br>
      <table class="cmd">
        <tbody>
          <tr>
            <td><strong>js&gt; function Person(name, age) {<br>
                &nbsp; &gt;&nbsp;&nbsp;&nbsp;&nbsp; this.name = name;<br>
                &nbsp; &gt;&nbsp;&nbsp;&nbsp;&nbsp; this.age = age;<br>
                &nbsp; &gt;&nbsp;&nbsp;&nbsp;&nbsp; this.toString = function() {<br>
                &nbsp; &gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return '[' + this.name + ', ' + this.age + ']';<br>
                &nbsp; &gt;&nbsp;&nbsp;&nbsp;&nbsp; };<br>
                &nbsp; &gt; }<br>
                js&gt; var p1 = new Person('Justin', 35);<br>
                js&gt; var p2 = new Person('Momor', 32);<br>
                js&gt; p1.toString == p2.toString;</strong><br>
              false<br>
              <strong>js&gt;</strong><br>
            </td>
          </tr>
        </tbody>
      </table>
      <br>
      The <span class="courier">toString</span> function actually doesn't close any resource. For efficiency, you may code as follows:<br>
      <blockquote><strong><span class="courier">function toString() {</span><br>
          <span class="courier">&nbsp;&nbsp;&nbsp; return '[' + this.name + ', ' + this.age + ']';</span><br>
          <span class="courier">}</span><br>
          <span class="courier"></span><br>
          <span class="courier">function Person(name, age) {</span><br>
          <span class="courier">&nbsp;&nbsp;&nbsp; this.name = name;</span><br>
          <span class="courier">&nbsp;&nbsp;&nbsp; this.age = age;</span><br>
          <span class="courier">&nbsp;&nbsp;&nbsp; this.toString = toString;</span><br>
          <span class="courier">}</span><br>
        </strong></blockquote>
      Although it solves the problem of repeatedly creating functions but the name 'toString' has one foot in the global scope. In fact, if you know every function has a <span
        class="courier">prototype</span> property, you can do as follows:<br>
      <table class="cmd">
        <tbody>
          <tr>
            <td><strong>js&gt; function Person(name, age) {<br>
                &nbsp; &gt;&nbsp;&nbsp;&nbsp;&nbsp; this.name = name;<br>
                &nbsp; &gt;&nbsp;&nbsp;&nbsp;&nbsp; this.age = age;<br>
                &nbsp; &gt; }<br>
                js&gt; Person.prototype.toString = function() {<br>
                &nbsp; &gt;&nbsp;&nbsp;&nbsp;&nbsp; return '[' + this.name + ', ' + this.age + ']';<br>
                &nbsp; &gt; };<br>
              </strong>function () {<br>
              &nbsp;&nbsp;&nbsp; return "[" + this.name + ", " + this.age + "]";<br>
              }<strong><br>
                <br>
                js&gt; var p1 = new Person('Justin', 35);<br>
                js&gt; var p2 = new Person('Momor', 32);<br>
                js&gt; p1<br>
              </strong>[Justin, 35]<strong><br>
                js&gt; p2<br>
              </strong>[Momor, 32]<strong><br>
                js&gt;</strong><br>
            </td>
          </tr>
        </tbody>
      </table>
      <br>
      When you use <span class="courier">new</span> and a constructor function to create an instance, JavaScript first creates a plain object and the <span
        class="courier">prototype</span> property of the constructor function is set as the prototype object of the plain object. After that, <span
        class="courier">this</span> refers to the plain object and the constructor function is called.<br>
      <br>
      When JavaScript looks up a property, it first searches properties on the instance. In the above example, <span
        class="courier">p1</span> has properties <span class="courier">name</span> and <span
        class="courier">age</span> so the corresponding values of them are retrieved. If the instance itself doesn't have the properties, JavaScript searches the prototype object of the instance. The prototype object is assigned when calling a constructor function. In the above example, <span
        class="courier">p1</span> itself has no <span class="courier">toString</span> so JavaScript searches the prototype object of <span
        class="courier">p1</span> and it's the same object as <span class="courier">Person.prototype</span>. The <span
        class="courier">toString</span> property is found on the <span
        class="courier">Person.prototype</span> so the function referred by <span
        class="courier">toString</span> is executed.<br>
      <br>
      It should be noted that the prototype object is searched only if there's no property on the instance itself. If you add a property to an instance, only the instance owns the property. You don't add the property to the prototype object of the instance. For example:&nbsp; <br>
      <table class="cmd">
        <tbody>
          <tr>
            <td><strong>js&gt; function Some() {}<br>
                js&gt; Some.prototype.data = 10;<br>
              </strong>10<strong><br>
                js&gt; var s = new Some();<br>
                js&gt; s.data;<br>
              </strong>10<strong><br>
                js&gt; s.data = 20;<br>
              </strong>20<strong><br>
                js&gt; s.data;<br>
              </strong>20<strong><br>
                js&gt; Some.prototype.data;<br>
              </strong>10<strong><br>
                js&gt;</strong><br>
            </td>
          </tr>
        </tbody>
      </table>
      <br>
      In the above example, you add a <span class="courier">data</span> property to <span
        class="courier">s</span> but the value of <span class="courier">Some.prototype.data</span> is not affected.<br>
      <br>
      You can add properties to the <span class="courier">prototype</span> property of a constructor function at any time. New properties can be found through the prototype mechanism even if properties are added to the <span
        class="courier">prototype</span> property after an instance is created. For example: <br>
      <table class="cmd">
        <tbody>
          <tr>
            <td><strong>js&gt; function Some() {}<br>
                js&gt; var s = new Some();<br>
                js&gt; print(s.data);<br>
              </strong>undefined<strong><br>
                js&gt; Some.prototype.data = 10;<br>
              </strong>10<strong><br>
                js&gt; print(s.data);<br>
              </strong>10<strong><br>
                js&gt;</strong><br>
            </td>
          </tr>
        </tbody>
      </table>
      <br>
      It's mentioned in <a href="Constructors.html">Constructors</a>. If you use <span
        class="courier">new</span> to create an instance, it owns a <span
        class="courier">constructor</span> property which refers to the constructor function. In fact, every time a <span
        class="courier">Function</span> instance is created, a plain object is created and set to the <span
        class="courier">prototype</span> property of the <span class="courier">Function</span> instance. The plain object, of course, also has a <span
        class="courier">constructor</span> property. That's why you can find the <span
        class="courier">constructor</span> property for every object because it comes from the prototype object of an instance. For example: <br>
      <table class="cmd">
        <tbody>
          <tr>
            <td><strong>js&gt; function Some() {}<br>
                js&gt; Some.prototype.constructor;<br>
                <br>
              </strong>function Some() {<br>
              }<strong><br>
                <br>
                js&gt;</strong><br>
            </td>
          </tr>
        </tbody>
      </table>
      <br>
      By default, the <span class="courier">prototype</span> property of a <span
        class="courier">Function</span> instance refers to an instance of <span
        class="courier">Object</span>. The object referred by <span class="courier">prototype</span> also has a <span
        class="courier">constructor</span> property. According to the prototype mechanism, if a property is not found on <span
        class="courier">prototype</span>, it will search the prototype object of <span
        class="courier">prototype</span>. For the above example, that is <span
        class="courier">Object.prototype</span>. That's because <span class="courier">prototype</span> refers to an instance of <span
        class="courier">Object</span> and the prototype object of <span
        class="courier">prototype</span> is <span class="courier">Object.prototype</span>. If the property is still not found, you will get <span
        class="courier">undefined</span>. This is the mechanism of JavaScript prototype chains.<br>
      <br>
      For example: <br>
      <table class="cmd">
        <tbody>
          <tr>
            <td><strong>js&gt; Object.prototype.xyz = 10;<br>
              </strong>10<strong><br>
                js&gt; function Some() {}<br>
                js&gt; var s = new Some();<br>
                js&gt; s.xyz;<br>
              </strong>10<strong><br>
                js&gt; s.__proto__ == Some.prototype;<br>
              </strong>true<strong><br>
                js&gt; s.__proto__.__proto__ == Object.prototype;<br>
              </strong>true<strong><br>
                js&gt;</strong><br>
            </td>
          </tr>
        </tbody>
      </table>
      <br>
      In the above example, <span class="courier">__proto__</span> is a non-standard property in Rhino. You can use it to get the prototype object of an instance. By default, it's the <span
        class="courier">prototype</span> property of a constructor function. Although the <span
        class="courier">Some</span> instance and <span class="courier">Some.prototype</span> both have no xyz, it will look up the prototype chain. The <span
        class="courier">xyz</span> property is finally found on <span class="courier">Object.prototype</span>. It is not recommended to add properties to <span
        class="courier">Object.prototype</span> because this will affect all instances in JavaScript. The above example is just for a demonstration. <br>
      <br>
      You can also use the <span class="courier">isPrototypeOf</span> function to check whether an object is the prototype object of another object. For example:&nbsp; <br>
      <table class="cmd">
        <tbody>
          <tr>
            <td><strong>js&gt; var arr = [];<br>
                js&gt; Array.prototype.isPrototypeOf(arr);<br>
              </strong>true<strong><br>
                js&gt; Function.prototype.isPrototypeOf(Array);<br>
              </strong>true<strong><br>
                js&gt; Object.prototype.isPrototypeOf(Array.prototype);<br>
              </strong>true<strong><br>
                js&gt;</strong><br>
            </td>
          </tr>
        </tbody>
      </table>
      <br>
      When <span class="courier">for in</span> iterates properties of an object, it will iterate all iterable properties along the prototype chain. If you <span
        class="courier">delete</span> a property of an object, it will delete the first property encountered on the prototype chain.<br>
      <br>
      <br>
      <p></p>
      <p></p>
      <ul>
      </ul>
    </div>
    <div class="aside">
      <script type="text/javascript"><!--
google_ad_client = "pub-9750319131714390";
google_ad_width = 160;
google_ad_height = 600;
google_ad_format = "160x600_as";
google_ad_type = "text_image";
google_ad_channel = "";
//-->
      </script>
      <script type="text/javascript" src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
      </script> <br>
      <br>
      <script type="text/javascript"><!--
google_ad_client = "pub-9750319131714390";
google_ad_width = 160;
google_ad_height = 600;
google_ad_format = "160x600_as";
google_ad_type = "text_image";
google_ad_channel = "";
//-->
      </script>
      <script type="text/javascript" src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
      </script> <br>
      <br>
      <script type="text/javascript"><!--
google_ad_client = "pub-9750319131714390";
google_ad_width = 160;
google_ad_height = 600;
google_ad_format = "160x600_as";
google_ad_type = "text_image";
google_ad_channel = "";
//-->
      </script>
      <script type="text/javascript" src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
      </script> <br>
      <br>
      <br>
    </div>
    <script src="http://www.google-analytics.com/urchin.js" type="text/javascript">
</script> <script type="text/javascript">
_uacct = "UA-143766-1";
urchinTracker();
</script> </body>
</html>
