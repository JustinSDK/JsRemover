<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html dir="ltr" lang="en">
  <head>
    <meta http-equiv="content-type" content="text/html; charset=UTF-8">
    <title>Scope Chains</title>
    <meta content="caterpillar" name="author">
    <meta content="JavaScript scope-chain" name="keywords">
    <link href="css/std.css" rel="stylesheet" type="text/css">
  </head>
  <body>
    <div class="header">
      <div class="hgroup">
        <h3><a href="http://openhome.cc/eGossip/">From eGossip@Openhome</a></h3>
        <h1><a href="index.html">JavaScript Essence: Scope Chains<br>
          </a></h1>
      </div>
    </div>
    <div class="article">
      <div align="right"><a href="../../Gossip/JavaScript/ScopeChain.html">中文</a><br>
      </div>
      <br>
      I've talked about variable scopes in <a href="Variables.html">Variables</a>. One focus of the article is that variables declared with <span
        class="courier">var</span> have the same scope of the enclosing environment, but variables declared without <span
        class="courier">var</span> are properties of a global object. For JavaScript, this is enough to explain difference between using and not using <span
        class="courier">var</span>.<br>
      <br>
      In <a href="Closures.html">Closures</a>, the concept of free variables is enough to explain what a closure is. <br>
      <br>
      In fact, <strong>when JavaScript looks up a variable, it'll follow a scope chain to determine whether a variable exists or not.</strong> The scope chain mechanism explains why JavaScript has no block scope and how it implements a closure. <br>
      <br>
      To understand scope chains, we should understand the lexical scope of a function. The lexical scope is defined by the physical placement of a function within the code. For example:&nbsp; <br>
      <blockquote><strong><span class="courier">var x = 10;</span><br>
          <span class="courier">function outer() {</span><br>
          <span class="courier">&nbsp;&nbsp;&nbsp; var y = 20;</span><br>
          <span class="courier">&nbsp;&nbsp;&nbsp; function inner() {</span><br>
          <span class="courier">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; var z = 30;</span><br>
          <span class="courier">&nbsp;&nbsp;&nbsp; }</span><br>
          <span class="courier">}</span><br>
          <span class="courier">func();</span><br>
        </strong></blockquote>
      Physically, the function <span class="courier">inner</span> is wrapped by <span
        class="courier">outer</span> and <span class="courier">outer</span> is wrapped by the global context. This physical structure is statically defined and changeless in the code.<br>
      <br>
      The dynamic counterpart to the static lexical scope is the execution context created by every invocation of a function. Every piece of JavaScript code is executed in the execution context. Take the above code for example; a variable <span
        class="courier">x</span> is defined in the global execution context. Each invocation of a function, however, will create a new function execution context and then an activation object, also called a call object, with an <span
        class="courier">argument</span> property. <br>
      <br>
      Every function has an internal <span class="courier">[[scope]]</span> property (cannot be accessed directly). Every time the execution environment encounters a function, it will specify <span
        class="courier">[[scope]]</span> a scope chain and the call object of the function will be the first element. And then, variable declarations in the function are processed. Every variable of a function will be a property of the call object. (The call object is also called a variable object right now.)&nbsp; <br>
      <br>
      You cannot access <span class="courier">[[scope]]</span> of a function directly but Rhino interpreter gives you a non-standard <span
        class="courier">__parent__</span> property to retrieve the call object of the enclosing function. Take the above code for example; <span
        class="courier">outer.__parent__</span> is the call object of the global environment which wraps the <span
        class="courier">outer</span> function. For a top level function, that is the global object, the only object in the scope chain at that time. You can get the call object of <span
        class="courier">outer</span> through <span class="courier">inner.__parent__</span>. If you want to get next object in the scope chain, you can use <span
        class="courier">inner.__parent__.__parent__</span>. What you get is the global object this time. <br>
      <br>
      This process seems a little complex. They are nuts and bolts of an interpreter. In conclusion, you can look up variables along a scope chain. This is the basic way to search a variable in JavaScript. For example: <strong><br>
      </strong>
      <table class="cmd">
        <tbody>
          <tr>
            <td><strong>js&gt; function outer() {<br>
                &nbsp; &gt;&nbsp;&nbsp;&nbsp;&nbsp; var y = 20;<br>
                &nbsp; &gt;&nbsp;&nbsp;&nbsp;&nbsp; function inner() {<br>
                &nbsp; &gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; var z = 30;<br>
                &nbsp; &gt;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
                &nbsp; &gt;&nbsp;&nbsp;&nbsp;&nbsp; return inner;<br>
                &nbsp; &gt; }<br>
                js&gt; var f = outer();<br>
                js&gt; outer.__parent__ == this;</strong><br>
              true<br>
              <strong>js&gt; f.__parent__.__parent__ == this;</strong><br>
              true<br>
              <strong>js&gt; f.__parent__.y;</strong><br>
              20<br>
              <strong>js&gt; f.__parent__.__parent__.x;</strong><br>
              10<br>
              <strong>js&gt;</strong><br>
            </td>
          </tr>
        </tbody>
      </table>
      <br>
      A variable is actually a property of a call object. (Activation Object and Variable Object are synonyms of Call Object.) For the above code, you can refer to the call object of <span
        class="courier">inner</span> by <span class="courier">inner.__parent__</span>. The variable <span
        class="courier">y</span> defined in <span class="courier">outer</span> is actually a property of the call object. Using <span
        class="courier">f.__parent__.__parent__</span> will get next object in the scope chain. That's the global object. <br>
      <br>
      Take the following for example: <strong><br>
      </strong>
      <table class="cmd">
        <tbody>
          <tr>
            <td><strong>js&gt; function func() {<br>
                &nbsp; &gt;&nbsp;&nbsp;&nbsp;&nbsp; print(m);<br>
                &nbsp; &gt;&nbsp;&nbsp;&nbsp;&nbsp; var m = 10;<br>
                &nbsp; &gt;&nbsp;&nbsp;&nbsp;&nbsp; print(m);<br>
                &nbsp; &gt; }<br>
                js&gt; func();<br>
              </strong>undefined<br>
              10<br>
              <strong>js&gt;</strong><br>
            </td>
          </tr>
        </tbody>
      </table>
      <br>
      If you look at it step by step, it's just like:<br>
      <blockquote><strong><span class="courier">function func() {</span><br>
          <span class="courier">&nbsp;&nbsp;&nbsp; print(m);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // variableObject = { m : undefined };</span><br>
          <span class="courier">&nbsp;&nbsp;&nbsp; var m = 10;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // variableObject = { m : 10 };</span><br>
          <span class="courier">&nbsp;&nbsp;&nbsp; print(m);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // variableObject = { m : 10 };</span><br>
          <span class="courier">}</span><br>
        </strong></blockquote>
      Using the non-standard <span class="courier">__parent__</span>, you can also get the same results: <strong><br>
      </strong>
      <table class="cmd">
        <tbody>
          <tr>
            <td><strong>js&gt; function func() {<br>
                &nbsp; &gt;&nbsp;&nbsp;&nbsp;&nbsp; function inner() {}<br>
                &nbsp; &gt;&nbsp;&nbsp;&nbsp;&nbsp; print(inner.__parent__.m);<br>
                &nbsp; &gt;&nbsp;&nbsp;&nbsp;&nbsp; var m = 10;<br>
                &nbsp; &gt;&nbsp;&nbsp;&nbsp;&nbsp; print(inner.__parent__.m);<br>
                &nbsp; &gt; }<br>
                js&gt; func();<br>
              </strong>undefined<br>
              10<strong><br>
                js&gt;</strong><br>
            </td>
          </tr>
        </tbody>
      </table>
      <br>
      While JavaScript is searching a variable, it will search the first object in the scope chain. If there's no corresponding property on it, try to search next object of the scope chain. If it's still not found, search the third object and so on. Continue this process until the global object is reached. <br>
      <br>
      Let's see why a local variable overwrites a global variable. <br>
      <blockquote><strong><span class="courier">var x = 10;</span><br>
          <span class="courier">function func() {</span><br>
          <span class="courier">&nbsp;&nbsp;&nbsp; var x = 20;</span><br>
          <span class="courier">&nbsp;&nbsp;&nbsp; print(x);</span><br>
          <span class="courier">}</span></strong><br>
      </blockquote>
      We can explain it from points of a scope chain. While searching a variable <span
        class="courier">x</span><span class="courier"></span>, it will see if there's a property <span
        class="courier">x</span> on the call object of <span class="courier">func</span> and the value is 20. <strong><br>
      </strong>
      <table class="cmd">
        <tbody>
          <tr>
            <td><strong>js&gt; var x = 10;<br>
                js&gt; function func() {<br>
                &nbsp; &gt;&nbsp;&nbsp;&nbsp;&nbsp; function inner() {}<br>
                &nbsp; &gt;&nbsp;&nbsp;&nbsp;&nbsp; var x = 20;<br>
                &nbsp; &gt;&nbsp;&nbsp;&nbsp;&nbsp; print(inner.__parent__.x);<br>
                &nbsp; &gt; }<br>
                js&gt; func();<br>
              </strong>20<strong><br>
                js&gt;</strong><br>
            </td>
          </tr>
        </tbody>
      </table>
      <br>
      Let's see a closure example:<br>
      <blockquote><strong><span class="courier">function doSome() {</span><br>
          <span class="courier">&nbsp;&nbsp;&nbsp; var x = 10;</span><br>
          <span class="courier">&nbsp;&nbsp;&nbsp; function f(y) {</span><br>
          <span class="courier">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return x + y;</span><br>
          <span class="courier">&nbsp;&nbsp;&nbsp; }</span><br>
          <span class="courier">&nbsp;&nbsp;&nbsp; return f;</span><br>
          <span class="courier">}</span><br>
        </strong></blockquote>
      The call object of <span class="courier">f</span> has no property <span
        class="courier">x</span> so trying to search <span class="courier">x</span> on the call object of the enclosing <span
        class="courier">doSome</span>. That is to search an <span class="courier">x</span> property on <span
        class="courier">f.__parent__</span> and find it this time.<br>
      <br>
      If you understand the concept of a scope chain, combine with the non-standard <span
        class="courier">__parent__</span>, you can play magic as follows: <strong><br>
      </strong>
      <table class="cmd">
        <tbody>
          <tr>
            <td><strong>js&gt; function func() {<br>
                &nbsp; &gt;&nbsp;&nbsp;&nbsp;&nbsp; function inner() {}<br>
                &nbsp; &gt;&nbsp;&nbsp;&nbsp;&nbsp; inner.__parent__.y = 30;<br>
                &nbsp; &gt;&nbsp;&nbsp;&nbsp;&nbsp; print(y);<br>
                &nbsp; &gt; }<br>
                js&gt; func();<br>
              </strong>30<strong><br>
                js&gt;</strong><br>
            </td>
          </tr>
        </tbody>
      </table>
      <br>
      Even though <span class="courier">func</span> doesn't use <span
        class="courier">var</span> to declare <span class="courier">y</span>, you can still print the value of <span
        class="courier">y</span>. <br>
      <br>
      So you can say that, in JavaScript, all variables are properties of an object. <br>
      <br>
      By the way, if you use <span class="courier">new</span> and the <span
        class="courier">Function</span> constructor to create a function, it always searches properties of the global object to find a variable. For example:&nbsp; <strong><br>
      </strong>
      <table class="cmd">
        <tbody>
          <tr>
            <td><strong>js&gt; var x = 10;<br>
                js&gt; function func() {<br>
                &nbsp; &gt;&nbsp;&nbsp;&nbsp;&nbsp; var x = 20;<br>
                &nbsp; &gt;&nbsp;&nbsp;&nbsp;&nbsp; var f = new Function('return x;');<br>
                &nbsp; &gt;&nbsp;&nbsp;&nbsp;&nbsp; print(f.__parent__.x);<br>
                &nbsp; &gt;&nbsp;&nbsp;&nbsp;&nbsp; return f();<br>
                &nbsp; &gt; };<br>
                js&gt; func();<br>
              </strong>10<br>
              10<strong><br>
                js&gt;</strong><br>
            </td>
          </tr>
        </tbody>
      </table>
      <br>
      <br>
      <p></p>
      <p></p>
      <ul>
      </ul>
    </div>
    <div class="aside">
      
       <br>
      <br>
      
       <br>
      <br>
      
       <br>
      <br>
      <br>
    </div>
      </body>
</html>
