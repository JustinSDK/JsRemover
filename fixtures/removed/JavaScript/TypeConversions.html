<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html dir="ltr" lang="en">
  <head>
    <meta http-equiv="content-type" content="text/html; charset=UTF-8">
    <title>Type Conversions</title>
    <meta content="caterpillar" name="author">
    <meta content="JavaScript type-conversion" name="keywords">
    <link href="css/std.css" rel="stylesheet" type="text/css">
  </head>
  <body>
    <div class="header">
      <div class="hgroup">
        <h3><a href="http://openhome.cc/eGossip/">From eGossip@Openhome</a></h3>
        <h1><a href="index.html">JavaScript Essence: Type Conversions<br>
          </a></h1>
      </div>
    </div>
    <div class="article">
      <div align="right"><a href="../../Gossip/JavaScript/TypeConversion.html">中文</a><br>
      </div>
      <br>
      On the classification of programming languages, there’re so-called <strong>strongly typed</strong> and <strong>weakly typed languages</strong>. Strong typing and weak typing are relatively speaking. There's no clear-cut distinction between them.<br>
      <br>
      Java are often said to be more strongly typed. This means that Java has less implicit type conversions on operations involving values of different types. For example, the type of Java strings is <span
        class="courier">String</span> and you cannot do the following in Java: <br>
      <blockquote><strong><span class="courier">String number1 = "3";</span><br>
          <span class="courier">String number2 = "2";</span><br>
          <span class="courier">int result = number1 - number2;</span><br>
        </strong></blockquote>
      In strongly typed languages, you need explicit type conversions or parsing before performing a calculation. For example:&nbsp; <br>
      <blockquote><b><span class="courier">String number1 = "3";</span><br>
          <span class="courier"> String number2 = "2";</span><br>
          <span class="courier"> int result = Integer.parseInt(number1) - Integer.parseInt(number2);</span><br>
        </b></blockquote>
      JavaScript is a weakly typed language. The <span class="courier">-</span> operator allows subtracting a string to a string.<br>
      <table class="cmd">
        <tbody>
          <tr>
            <td><strong>js&gt; var number1 = '3';<br>
                js&gt; var number2 = '2';<br>
                js&gt; var result = number1 - number2;<br>
                js&gt; result;</strong><br>
              1<br>
              <strong>js&gt; typeof result;</strong><br>
              number<br>
              <strong>js&gt;</strong><br>
            </td>
          </tr>
        </tbody>
      </table>
      <br>
      Explicit type conversions or parsing of strongly typed languages avoids many errors due to unexpected type conversions but brings in tedious syntax. Weakly typed languages are opposite. They have advantages of brief syntax but have to pay more attention to problems of unexpected type conversions.<br>
      <br>
      JavaScript's primitive types, such as <span class="courier">number</span>, <span
        class="courier">string</span> and <span class="courier">boolean</span>, will automatically be converted to their corresponding wrapper types, such as <span
        class="courier">Number</span>, <span class="courier">String</span> and <span
        class="courier">Boolean</span>, if necessary. For example:&nbsp;&nbsp; <br>
      <table class="cmd">
        <tbody>
          <tr>
            <td><strong>js&gt; var num = 10;<br>
                js&gt; var binary = num.toString(2);<br>
                js&gt; binary;<br>
              </strong>1010<strong><br>
                js&gt; var binary = (10).toString(2);<br>
                js&gt; binary;<br>
              </strong>1010<strong><br>
                js&gt;</strong><br>
            </td>
          </tr>
        </tbody>
      </table>
      <br>
      The variable <span class="courier">num</span> is assigned <span
        class="courier">10</span>, but the method <span class="courier">toString</span> is available on the instance of <span
        class="courier">Number</span>. The instance of <span class="courier">Number</span> is used to wrap the value of <span
        class="courier">num</span> so you get the way to call <span class="courier">toString</span>. As for a number literal, you can use <span
        class="courier">()</span> to wrap it<span class="courier"></span> and then call <span
        class="courier">toString</span> directly. JavaScript will type-convert it automatically. <br>
      <br>
      Similarly, a <span class="courier">string</span> value will be automatically wrapped in an instance of <span
        class="courier">String</span> if necessary. For example:&nbsp; <br>
      <table class="cmd">
        <tbody>
          <tr>
            <td><strong>js&gt; var text = 'caterpillar';<br>
                js&gt; text.toUpperCase();<br>
              </strong>CATERPILLAR<strong><br>
                js&gt; 'caterpillar'.toUpperCase();<br>
              </strong>CATERPILLAR<strong><br>
                js&gt;</strong><br>
            </td>
          </tr>
        </tbody>
      </table>
      <br>
      The method <span class="courier">toUpperCase</span> is available on the instance of <span
        class="courier">String</span>. The execution environment will wrap a <span
        class="courier">string</span> value as an instance of <span class="courier">String</span> if necessary, and then allows you to call <span
        class="courier">toUpperCase</span>.<br>
      <br>
      You can create a wrapper object directly. For example: <br>
      <table class="cmd">
        <tbody>
          <tr>
            <td><strong>js&gt; var num = new Number(10);<br>
                js&gt; var text = new String('caterpillar');<br>
                js&gt; typeof 10;<br>
              </strong>number<strong><br>
                js&gt; typeof num;<br>
              </strong>object<strong><br>
                js&gt; typeof 'caterpillar';<br>
              </strong>string<strong><br>
                js&gt; typeof text;<br>
              </strong>object<strong><br>
                js&gt;</strong><br>
            </td>
          </tr>
        </tbody>
      </table>
      <br>
      As for methods on the instance of <span class="courier">Number</span>, <span
        class="courier">String</span> and <span class="courier">Boolean</span>, take a look at: <br>
      <ul>
        <li> <a href="http://www.aptana.com/reference/html/api/Number.html">Number</a></li>
        <li> <a href="http://www.aptana.com/reference/html/api/String.html">String</a></li>
        <li> <a href="http://www.aptana.com/reference/html/api/Boolean.html">Boolean</a></li>
      </ul>
      You can use <span class="courier">parseInt</span> and <span class="courier">parseFloat</span> to convert a <span
        class="courier">string</span> value into a <span class="courier">numeber</span> value. The advantage is that they ignore non-numeric characters in the string tail<span
        class="courier"></span>. For example:&nbsp; <br>
      <table class="cmd">
        <tbody>
          <tr>
            <td><strong>js&gt; parseInt('10 years old...XD');<br>
              </strong>10<strong><br>
                js&gt; parseFloat('3.14159......');<br>
              </strong>3.14159<strong><br>
                js&gt; parseInt('010', 10)<br>
              </strong>10<strong><br>
                js&gt; parseInt('010', 8)<br>
              </strong>8<strong><br>
                js&gt;</strong><br>
            </td>
          </tr>
        </tbody>
      </table>
      <br>
      In the above example, Radix 10 and 8 specified to <span class="courier">parseInt</span> are necessary. If a string begins with <span
        class="courier">'0x'</span>, the radix is 16 (hexadecimal). If a string<span
        class="courier"></span> begins with <span class="courier">'0'</span>, it's recommended to specify a radix 8 or 10. A string begins with any other values, the radix is 10 (decimal).<br>
      <br>
      If a string represents a number, it can be operated by <span class="courier">+, -, *, /</span> operators. But take care, <span
        class="courier">+</span> has a high priority in string concatenation rather than converting them to a <span
        class="courier">number</span> value for addition. As for <span
        class="courier">-, *</span> and <span class="courier">/</span>, operands will be converted to <span
        class="courier">number</span> values for subtraction, multiplication and division. For example:&nbsp; <br>
      <table class="cmd">
        <tbody>
          <tr>
            <td><strong>js&gt; '6' + '2'<br>
              </strong>62<strong><br>
                js&gt; '6' - '2'<br>
              </strong>4<strong><br>
                js&gt; '6' * '2'<br>
              </strong>12<strong><br>
                js&gt; '6' / '2'<br>
              </strong>3<strong><br>
                js&gt;</strong><br>
            </td>
          </tr>
        </tbody>
      </table>
      <br>
      If <span class="courier">boolean</span> values are combined with <span
        class="courier">+, -, *</span> and <span class="courier">/</span> to perform mathematical operations, <span
        class="courier">true</span> will be treated as <span class="courier">1</span>, and <span
        class="courier">false</span> as zero. For example:<br>
      <table class="cmd">
        <tbody>
          <tr>
            <td><strong>js&gt; 1 + true;<br>
              </strong>2<strong><br>
                js&gt; 1 + false;<br>
              </strong>1<strong><br>
                js&gt;</strong><br>
            </td>
          </tr>
        </tbody>
      </table>
      <br>
      The <span class="courier">boolean</span> values<span class="courier"></span> are very interesting. In conditional expressions, everything can be treated as a <span
        class="courier">boolean</span> value. An easy formula to remember is: <strong>The <span
          class="courier">0, NaN, '', null</span> and <span class="courier">undefined</span> are always <span
          class="courier">false</span> , and all other values are <span
          class="courier">true</span>.</strong> The <span class="courier">0, NaN, '', null, undefined</span> and, of course, <span
        class="courier">false</span> are so-called <strong>"false family"</strong>.<br>
      <br>
      For example, if a property doesn't exist on an object, trying to get the value will obtain <span
        class="courier">undefined</span>. So, if you want to know whether a property exists on an object, you can do as such:<br>
      <table class="cmd">
        <tbody>
          <tr>
            <td><strong>js&gt; function exist(obj) {<br>
                &nbsp; &gt;&nbsp;&nbsp;&nbsp;&nbsp; if(obj.x) {<br>
                &nbsp; &gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print('x exists.');<br>
                &nbsp; &gt;&nbsp;&nbsp;&nbsp;&nbsp; } else {<br>
                &nbsp; &gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print('x doesn\'t exist.');<br>
                &nbsp; &gt;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
                &nbsp; &gt; }<br>
                js&gt; var o = {};<br>
                js&gt; exist(o);<br>
              </strong>x doesn't exist.<strong><br>
                js&gt; o.x = 10;<br>
              </strong>10<strong><br>
                js&gt; exist(o);<br>
              </strong>x exists.<strong><br>
                js&gt;</strong><br>
            </td>
          </tr>
        </tbody>
      </table>
      <br>
      The <span class="courier">undefined</span> will be treated as <span
        class="courier">false</span> in a <span class="courier">if</span> statement. To prevent the property <span
        class="courier">x</span> from error evaluation due to being specified as<span
        class="courier"> 0, NaN</span> or <span class="courier">null</span>, you can do a more strict checking. For example: <br>
      <table class="cmd">
        <tbody>
          <tr>
            <td><strong>js&gt; function exist(obj) {<br>
                &nbsp; &gt;&nbsp;&nbsp;&nbsp;&nbsp; if(typeof(obj.x) != 'undefined') {<br>
                &nbsp; &gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print('x exists.');<br>
                &nbsp; &gt;&nbsp;&nbsp;&nbsp;&nbsp; } else {<br>
                &nbsp; &gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print('x doesn\'t exist.');<br>
                &nbsp; &gt;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
                &nbsp; &gt; }<br>
                js&gt; var o = { x : 0 };<br>
                js&gt; exist(o);<br>
              </strong>x exists.<strong><br>
                js&gt;</strong><br>
            </td>
          </tr>
        </tbody>
      </table>
      &nbsp; <br>
      Type conversions also happen in the equality comparison. There are two equality operators, <strong><span
          class="courier">==</span></strong> and <strong><span class="courier">===</span></strong>, in JavaScript, both can be used to test if two values or references are equivalent. Simply speaking, <span
        class="courier">==</span> tries to convert operands into the same type, and then performs the equality comparision. The <span
        class="courier">===</span> operator returns <span class="courier">false</span> immediately if operands have different types. For example: <br>
      <table class="cmd">
        <tbody>
          <tr>
            <td><strong>js&gt; '' == 0;<br>
              </strong>true<strong><br>
                js&gt; '' === 0;<br>
              </strong>false<strong><br>
                js&gt; null == undefined;<br>
              </strong>true<strong><br>
                js&gt; null === undefined;<br>
              </strong>false<strong><br>
                js&gt; 1 == true;<br>
              </strong>true<strong><br>
                js&gt; 1 === true;<br>
              </strong>false<strong><br>
                js&gt;</strong><br>
            </td>
          </tr>
        </tbody>
      </table>
      &nbsp; <br>
      Simply speaking, <span class="courier">==</span> performs loose comparison, allow comparison after type conversion.&nbsp; <span
        class="courier">===</span> performs more strict comparison, <span
        class="courier">true</span> is possible only if operands have the same type. It's better to do some test if you're not sure. For example: <br>
      <table class="cmd">
        <tbody>
          <tr>
            <td><strong>js&gt; false == undefined;<br>
              </strong>false<strong><br>
                js&gt;</strong><br>
            </td>
          </tr>
        </tbody>
      </table>
      &nbsp; <br>
      In weakly typed languages, type conversions often happen automatically.&nbsp; It's better to get your hands dirty doing some tests if you want to avoid error evaluations or operations due to unnecessary type conversions. In the example above, you can also do the conversion explicitly:<br>
      <table class="cmd">
        <tbody>
          <tr>
            <td><strong>js&gt; false == Boolean(undefined);<br>
              </strong>true<strong><br>
                js&gt;</strong><br>
            </td>
          </tr>
        </tbody>
      </table>
      &nbsp; <br>
      <br>
      <br>
      <p></p>
      <p></p>
      <ul>
      </ul>
    </div>
    <div class="aside">
      
       <br>
      <br>
      
       <br>
      <br>
      
       <br>
      <br>
      <br>
    </div>
      </body>
</html>
