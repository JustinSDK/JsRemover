<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html dir="ltr" lang="en">
  <head>
    <meta content="text/html; charset=UTF-8" http-equiv="content-type">
    <title>Asynchronous Request Objects</title>
    <meta content="caterpillar" name="author">
    <meta content="JavaScript" name="keywords">
    <link href="css/std.css" rel="stylesheet" type="text/css">
  </head>
  <body>
    <div class="header">
      <div class="hgroup">
        <h3><a href="http://openhome.cc/eGossip/">From eGossip@Openhome</a></h3>
        <h1><a href="index.html">JavaScript Essence: Asynchronous Request Objects<br>
          </a></h1>
      </div>
    </div>
    <div class="article">
      <div style="text-align: right;"><a href="../../Gossip/JavaScript/XMLHttpRequest.html">中文</a></div>
      <br>
      The term Ajax was first mentioned in the article <a href="http://www.adaptivepath.com/ideas/ajax-new-approach-web-applications">Ajax: A New Approach to Web Applications</a> by Jesse James Garrett. This article talked that Google Suggest and Google Maps used the approach have been calling Ajax in Adaptive Path. <br>
      <br>
      <div style="margin-left: 40px;"><em><span style="font-weight: bold;">"Google Suggest and Google Maps are two examples of a new approach to web applications that we at Adaptive Path have been calling Ajax. The name is shorthand for Asynchronous JavaScript + XML, and it represents a fundamental shift in what's possible on the Web."&nbsp;</span></em> </div>
      <br>
      This quotation says that, Ajax is a concept for Asynchronous <span
        style="font-weight: bold;">JavaScript + XML</span>. XML is used for exchanging structured data between applications, but not the only one usable format. <br>
      <br>
      The core concept of Ajax is asynchronous, and why asynchronous? Browsers have their default action for the traditional form submitting or hyperlink clicking. That is transferring a request synchronously, waiting for the response from a server, and refreshing the page. What users can do is to wait for the latest response displayed in a new page. If they perform a new action before the response is completed, the browser may abort the previous request. After the response is completed, users are shown a new page; even the updated area is only a small part of the all page. <br>
      <br>
      If the request and response can be asynchronous, that is, after making the request, the browser doesn’t have to wait for a response from a server. The user can perform other action in the same page, yet doesn't interrupt the original request. After the server complete the request and send back a response, the browser will call the corresponding function to process the response, such as using DOM API to update one part of the page. If all these are possible, various interactive models will be opened. <br>
      <br>
      Browsers use <span class="courier">XMLHttpRequest</span> to create asynchronous objects, but it has browser-compatibility problems. Internet Explorer 6 and its previous versions use <span
        class="courier">ActiveXObject</span> to implement asynchronous objects. <span
        class="courier">XMLHttpRequest</span> is supported from Internet Explorer 7. Even so, the <span
        class="courier">ActiveXObject</span> implementations are different among different versions of Internet Explorer. The basic implementation is <span
        class="courier">Microsoft.XMLHTTP</span>. The newer implementations are <span
        class="courier">Msxml2.XMLHTTP</span>, <span class="courier">Msxml2.XMLHTTP.3.0</span>, <span
        class="courier">Msxml2.XMLHTTP.4.0</span>, etc. <span class="courier">Microsoft.XMLHTTP</span> has better compatibility, so most libraries simply try to use <span
        class="courier">Microsoft.XMLHTTP</span> and <span class="courier">Msxml2.XMLHTTP</span>, like Prototype, or only try to use <span
        class="courier">Microsoft.XMLHTTP</span>, such as jQuery. <br>
      <br>
      Creating an asynchronous object in a cross-browser way can be written as follows: <br>
      <div class="courier" style="margin-left: 40px;"><strong> <span>var xhr = function() {</span></strong><span><strong><br>
          </strong></span><span><strong>&nbsp;&nbsp;&nbsp; if(window.XMLHttpRequest) {</strong></span><span><strong><br>
          </strong></span><span><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return new XMLHttpRequest();</strong></span><span><strong><br>
          </strong></span><span><strong>&nbsp;&nbsp;&nbsp; }</strong></span><span><strong><br>
          </strong></span><span><strong>&nbsp;&nbsp;&nbsp; else {</strong></span><span><strong><br>
          </strong></span><span><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; try {</strong></span><span><strong><br>
          </strong></span><span><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return new ActiveXObject('Microsoft.XMLHTTP');</strong></span><span><strong><br>
          </strong></span><span><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</strong></span><span><strong><br>
          </strong></span><span><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; catch(e) {</strong></span><span><strong><br>
          </strong></span><span><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; throw new Error('XMLHttpRequest not supported');</strong></span><span><strong><br>
          </strong></span><span><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</strong></span><span><strong><br>
          </strong></span><span><strong>&nbsp;&nbsp;&nbsp; }</strong></span><span><strong><br>
          </strong></span><span><strong>};</strong></span></div>
      <br>
      The <span class="courier">xhr</span> function detects whether the <span
        class="courier">XMLHttpRequest</span> property exists. Create the instance if that's <span
        class="courier">true</span>, or try to create an <span class="courier">ActiveXObject</span> instance. Throw an error if it fails. <br>
      <br>
      Also note that, the <span class="courier">XMLHttpRequest</span> implementation of Internet Explorer 7 can't request local files even the page comes from a local drive. If you really want to do so, use <span
        class="courier">ActiveXObject</span> instead. <br>
      <br>
      If you need to create asynchronous objects frequently, and won't be burdened with the frequent detection of <span
        class="courier">XMLHttpRequest</span>, you can do as follows: <br>
      <div class="courier" style="margin-left: 40px;"> <span><strong>var xhr = window.XMLHttpRequest &amp;&amp; </strong></span><span><strong><br>
          </strong></span><span><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (window.location.protocol !== 'file:' || !window.ActiveXObject) ?</strong></span><span><strong><br>
          </strong></span><span><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; function() {</strong></span><span><strong><br>
          </strong></span><span><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return new XMLHttpRequest();</strong></span><span><strong><br>
          </strong></span><span><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } :</strong></span><span><strong><br>
          </strong></span><span><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; function() {</strong></span><span><strong><br>
          </strong></span><span><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; try {</strong></span><span><strong><br>
          </strong></span><span><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return new ActiveXObject('Microsoft.XMLHTTP');</strong></span><span><strong><br>
          </strong></span><span><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } catch(e) {</strong></span><span><strong><br>
          </strong></span><span><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; throw new Error('XMLHttpRequest not supported');</strong></span><span><strong><br>
          </strong></span><span><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</strong></span><span><strong><br>
          </strong></span><span><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; };</strong></span></div>
      <br>
      In the above example, the <span class="courier">xhr</span> function will create a <span
        class="courier">XMLHttpRequest</span> instance if the <span class="courier">XMLHttpRequest</span> property exists and the page doesn't come from a local drive; if the <span
        class="courier">XMLHttpRequest</span> property exists and the page comes from a local drive (this condition is considered for Internet Explorer 7), the <span
        class="courier">xhr</span> function will create an <span class="courier">ActiveXObject</span> instance. <br>
      <br>
      You can create an asynchronous object as follow:<br>
      <div style="margin-left: 40px;"><span><strong class="courier"> var request = xhr();</strong></span></div>
      <br>
      Creating an asynchronous object has browser-compatibility problems. Fortunately, the object's API has fewer differences. Some basic functions are as follows: <br>
      <ul>
        <li><span class="courier" style="font-weight: bold;"> void open(string method, string url[, boolean asynch, string username, string password])</span></li>
      </ul>
      <div style="margin-left: 40px;"> Open a connection to the server. The <span
          class="courier">method</span> parameter is the request type, like <span
          class="courier">'GET'</span>, <span class="courier">'POST'</span>, <span
          class="courier">'HEAD'</span>, etc. The <span class="courier">url</span> parameter is the server's url; if the request type is <span
          class="courier">'GET'</span>, request parameters and values can be appended to the url. The <span
          class="courier">asynch</span> parameter is a flag pointing out whether the request is asynchronous or not; if it's <span
          class="courier">true</span>, the request will be asynchronous. The <span
          class="courier">username</span> and <span class="courier">password</span> parameters are optional; depend on the server's requirement. </div>
      <br>
      <ul>
        <li> <span class="courier" style="font-weight: bold;">void setRequestHeader(string header, string value)</span></li>
      </ul>
      <div style="margin-left: 40px;"> Set a header and value for the HTTP request. It should be called before the <span
          class="courier">open</span> function and usually used when the&nbsp; <span
          class="courier">method</span> parameter is <span class="courier">'POST'</span>. </div>
      <br>
      <ul>
        <li><span class="courier"> <strong>void send(string content)</strong></span></li>
      </ul>
      <div style="margin-left: 40px;"> Send a request to the server. If the <span
          class="courier">method</span> parameter of <span class="courier">open</span> is <span
          class="courier">'GET'</span>, its <span class="courier">content</span> parameter should be <span
          class="courier">null</span>. If the request type is <span class="courier">'POST'</span>, the <span
          class="courier">content</span> parameter may be a string, XML, or JSON. They will be sent in the POST body. </div>
      <br>
      <ul>
        <li><span><strong class="courier"> void abort()</strong></span></li>
      </ul>
      <div style="margin-left: 40px;"> Abort the request.</div>
      <br>
      <ul>
        <li><span class="courier"> <strong>string getAllResponseHeaders()</strong></span></li>
      </ul>
      <div style="margin-left: 40px;"> Return a string containing all HTTP response headers. </div>
      <br>
      <ul>
        <li><strong><span class="courier"> string getResponseHeader(string header)</span></strong></li>
      </ul>
      <div style="margin-left: 40px;"> Return a string containing the specified response header. </div>
      <br>
      Usually, the default value <span class="courier">true</span> of the <span
        class="courier">open</span> function's third parameter is used. Sometimes, it may be set a <span
        class="courier">false</span> when we want to send a request synchronously. If you want to know the state of the request object, you can set the <span
        class="courier">onreadystatechange</span> property a callback function before calling the <span
        class="courier">open</span> function. Once the state is changed, the callback function is called. An example is as follow:<br>
      <div class="courier" style="margin-left: 40px;"> <span><strong>var request = xhr();</strong></span><span><strong><br>
          </strong></span><span><strong>request.onreadystatechange = function() {</strong></span><span><strong><br>
          </strong></span><span><strong>&nbsp;&nbsp;&nbsp; if(request.readyState === 4) {</strong></span><span><strong><br>
          </strong></span><span><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(request.state === 200) {</strong></span><span><strong><br>
          </strong></span><span><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // do some processing when HTTP 200 OK</strong></span><span><strong><br>
          </strong></span><span><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</strong></span><span><strong><br>
          </strong></span><span><strong>&nbsp;&nbsp;&nbsp; }</strong></span><span><strong><br>
          </strong></span><span><strong>};</strong></span><span><strong><br>
          </strong></span><span><strong>request.open('GET', 'data.txt');</strong></span><span><strong><br>
          </strong></span><span><strong>request.send(null);</strong></span></div>
      <br>
      The <span class="courier">readyState</span> property of the request object has four possible values representing four respective states. <br>
      <ul>
        <li> 0 - The <span class="courier">open</span> function is not called yet.</li>
        <li> 1 - The <span class="courier">open</span> function is called.</li>
        <li> 2 - The <span class="courier">send</span> function is called.</li>
        <li> 3 - Receiving the response.</li>
        <li> 4 - The response is completed. </li>
      </ul>
      It's common to do some processing when the <span class="courier">readyState</span> is 4. It's also suggested to ignore states other than 4 due to browser-compatibility problems. An asynchronous object's <span
        class="courier">status</span> represents the HTTP response code. The <span
        class="courier">statusText</span> property returns a string representing the status code in a friendly form. <br>
      <br>
      The <span class="courier">responseText</span> property returns a string representing the response text from the server. But it should be noticed that, if the server doesn't specify the charset, such as <span
        class="courier">'Content-Type: text/html; charset=Big5'</span>, the default charset of <span
        class="courier">responseText</span> is UTF-8. If the response is XML, use <span
        class="courier">responseXML</span> to get the corresponding DOM object.<br>
      <br>
      The following example demonstrates a simple but complete flow about how to get data asynchronously. The requested document includes Traditional Chinese characters, so it's saved as UTF-8. This example will request the document asynchronously and show the content without refreshing the page. <br>
      <ul>
        <li><a href="samples/AsynchronousRequestObjects-1.html">AsynchronousRequestObjects-1.html</a></li>
      </ul>
      <pre>&lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Strict//EN"&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;meta content="text/html; charset=UTF-8" http-equiv="content-type"&gt;
        &lt;script type="text/javascript"&gt;
            window.onload = function() {
                var xhr = window.XMLHttpRequest &amp;&amp; 
                      (window.location.protocol !== 'file:' 
                          || !window.ActiveXObject) ?
                       function() {
                           return new XMLHttpRequest();
                       } :
                       function() {
                          try {
                              return new ActiveXObject('Microsoft.XMLHTTP');
                          } catch(e) {
                              throw new Error('XMLHttpRequest not supported');
                          }
                       };
                       
                document.getElementById('req').onclick = function() {
                    var request = xhr();
                    request.onreadystatechange = function() {
                        if(request.readyState === 4) {
                            if(request.status === 200) {
                                document.getElementById('table').innerHTML = 
                                    request.responseText;
                            }
                        }
                    };
                    request.open('GET', 'XMLHttpRequest-1.txt');
                    request.send(null);
                };
            };
        &lt;/script&gt;        
    &lt;/head&gt;
    &lt;body&gt;
        &lt;button id='req'&gt;Get the table&lt;/button&gt;
        &lt;div id="table"&gt;&lt;/div&gt;
    &lt;/body&gt;
&lt;/html&gt;</pre>
      <br>
      I'll talk more about asynchronous request objects. If you are eager for more documentation about <span
        class="courier">XMLHttpRequest</span>, take a look at the following link. <br>
      <ul>
        <li><a href="http://www.w3.org/TR/XMLHttpRequest/"> http://www.w3.org/TR/XMLHttpRequest/</a></li>
      </ul>
      <br>
      <br>
      <br>
      <p></p>
      <p></p>
      <ul>
      </ul>
    </div>
    <div class="aside">
      
       <br>
      <br>
      
       <br>
      <br>
      
       <br>
      <br>
      <br>
    </div>
      </body>
</html>
